// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import '@account-abstraction/contracts/core/BaseAccount.sol';
import '@account-abstraction/contracts/core/Helpers.sol';


contract MyAccount is BaseAccount, Initializable {

    bytes32 public ownershipCommitment;

    IEntryPoint private immutable _entryPoint;
    event SimpleAccountInitialized(IEntryPoint indexed entryPoint, bytes32 indexed ownershipCommitment);

    constructor(IEntryPoint anEntryPoint) {
        _entryPoint = anEntryPoint;
        _disableInitializers();
    }
    /// @inheritdoc BaseAccount
    function entryPoint() public view virtual override returns (IEntryPoint) {
        return _entryPoint;
    }

    function initialize(bytes32 _ownershipCommitment) public virtual initializer {
        _initialize(_ownershipCommitment);
    }

    function _initialize(bytes32 _ownershipCommitment) internal virtual {
        ownershipCommitment = _ownershipCommitment;
        emit SimpleAccountInitialized(_entryPoint, ownershipCommitment);
    }

    /// implement template method of BaseAccount
    function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)
    internal override virtual returns (uint256 validationData) {
        // bytes32 hash = MessageHashUtils.toEthSignedMessageHash(userOpHash);
        // if (owner != ECDSA.recover(hash, userOp.signature))
        //     return SIG_VALIDATION_FAILED;
        return SIG_VALIDATION_SUCCESS;
    }
}