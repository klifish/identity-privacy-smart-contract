// utils.js
const { ethers } = require("hardhat");
const circomlibjs = require("circomlibjs");
const ffjavascript = require("ffjavascript");
// const AddressZero = ethers.constants.AddressZero;

let pedersenInstance;

async function pedersenHashMultipleInputs(inputs) {
  if (!Array.isArray(inputs)) {
    throw new Error("Inputs must be an array.");
  }

  // 1. 初始化 Pedersen 哈希函数
  const pedersen = await circomlibjs.buildPedersenHash();

  // 2. 将所有输入标准化为 32 字节 Uint8Array 格式
  const buffers = inputs.map(input => {
    const bigintInput = BigInt(input); // 确保输入为 BigInt
    return ffjavascript.utils.leInt2Buff(bigintInput, 32); // 转换为 32 字节 Uint8Array
  });

  // 3. 拼接所有 Uint8Array
  const concatenatedBuffer = new Uint8Array(buffers.reduce((totalLength, buffer) => totalLength + buffer.length, 0));
  let offset = 0;
  for (const buffer of buffers) {
    concatenatedBuffer.set(buffer, offset);
    offset += buffer.length;
  }

  // 4. 计算 Pedersen 哈希
  const hash = pedersen.hash(concatenatedBuffer);

  return hash; // 返回哈希结果 Uint8Array
}

function bitsToNum(bits) {
  if (!Array.isArray(bits)) {
    throw new Error("Input must be an array.");
  }
  if (bits.some(bit => bit !== 0 && bit !== 1)) {
    throw new Error("Bits array must contain only 0 or 1.");
  }

  let num = 0n; // Initialize the result as BigInt
  let weight = 1n; // Start with 2^0 = 1

  for (let bit of bits) {
    if (bit === 1) {
      num += weight; // Add the weight if the bit is 1
    }
    weight *= 2n; // Update the weight (2^i)
  }

  return num; // Return the resulting BigInt
}

function numToBits(inValue, n) {
  if (typeof inValue !== "bigint") {
    throw new Error(`Input value must be a BigInt. Received: ${typeof inValue}`);
  }

  const out = new Array(n).fill(0n); // Initialize output array as BigInt
  let lc1 = 0n; // Use BigInt for the accumulator
  let e2 = 1n;  // Use BigInt for the bit weights

  for (let i = 0; i < n; i++) {
    out[i] = (inValue >> BigInt(i)) & 1n; // Use BigInt-compatible right shift and bitwise AND
    if (out[i] * (out[i] - 1n) !== 0n) { // Ensure out[i] is either 0n or 1n
      throw new Error(`Invalid bit value at position ${i}: ${out[i]}`);
    }
    lc1 += out[i] * e2; // Accumulate the value
    e2 *= 2n;          // Update the weight as a BigInt
  }

  if (lc1 !== inValue) {
    throw new Error(`Validation failed: lc1 (${lc1}) !== inValue (${inValue})`);
  }

  return out.map(Number); // Convert the result to standard numbers if needed
}

function address2Uint8Array32(address) {
  addressBigInt = BigInt(address)
  // console.log("addressBigInt:", addressBigInt);

  addressBits = numToBits(addressBigInt, 256)
  // console.log("addressBits:", addressBits);

  addressBigInt = bitsToNum(addressBits)
  // console.log("addressBigInt:", addressBigInt);
  addressBuff = ffjavascript.utils.leInt2Buff(addressBigInt)

  ret = new Uint8Array(32);
  for (let i = 0; i < addressBuff.length; i++) {
    ret[i + 12] = addressBuff[i]
  }
  // console.log("ret:", ret);
  return ret;
}

async function computePedersenHash(message) {
  try {
    if (typeof message !== "string" || message.length === 0) {
      throw new Error("Message must be a non-empty string.");
    }

    // Initialize Pedersen hash
    if (!pedersenInstance) {
      pedersenInstance = await circomlibjs.buildPedersenHash();
    }

    // Convert message to Uint8Array
    const encodedMessage = new TextEncoder().encode(message);


    const encodedMessage32 = new Uint8Array(32);
    encodedMessage32.set(encodedMessage);

    // Compute Pedersen hash
    const hashBuffer = pedersenInstance.hash(encodedMessage32);

    let babyJub = await circomlibjs.buildBabyjub();
    let F = babyJub.F;
    const hP = babyJub.unpackPoint(hashBuffer);
    // console.log("hP[0]:", F.toObject(hP[0]));
    // console.log("hP[1]:", F.toObject(hP[1]));

    // Convert the resulting buffer to a BigInt
    const hashBigInt = ffjavascript.utils.leBuff2int(hashBuffer);
    // console.log("hashBigInt:", hashBigInt);

    return hashBigInt;
  } catch (error) {
    console.error("Error in computePedersenHash:", error.message);
    throw error;
  }
}

/**
 * Converts the proof JSON into an array of hexadecimal strings for Plonk verification.
 * @param {Object} proofJson - The proof object generated by snarkjs.plonk.fullProve.
 * @returns {Array} - An array of hexadecimal strings representing the proof.
 */
function parseProof(proofJson) {
  const proof = [
    "0x" + BigInt(proofJson.A[0]).toString(16),
    "0x" + BigInt(proofJson.A[1]).toString(16),
    "0x" + BigInt(proofJson.B[0]).toString(16),
    "0x" + BigInt(proofJson.B[1]).toString(16),
    "0x" + BigInt(proofJson.C[0]).toString(16),
    "0x" + BigInt(proofJson.C[1]).toString(16),
    "0x" + BigInt(proofJson.Z[0]).toString(16),
    "0x" + BigInt(proofJson.Z[1]).toString(16),
    "0x" + BigInt(proofJson.T1[0]).toString(16),
    "0x" + BigInt(proofJson.T1[1]).toString(16),
    "0x" + BigInt(proofJson.T2[0]).toString(16),
    "0x" + BigInt(proofJson.T2[1]).toString(16),
    "0x" + BigInt(proofJson.T3[0]).toString(16),
    "0x" + BigInt(proofJson.T3[1]).toString(16),
    "0x" + BigInt(proofJson.Wxi[0]).toString(16),
    "0x" + BigInt(proofJson.Wxi[1]).toString(16),
    "0x" + BigInt(proofJson.Wxiw[0]).toString(16),
    "0x" + BigInt(proofJson.Wxiw[1]).toString(16),
    "0x" + BigInt(proofJson.eval_a).toString(16),
    "0x" + BigInt(proofJson.eval_b).toString(16),
    "0x" + BigInt(proofJson.eval_c).toString(16),
    "0x" + BigInt(proofJson.eval_s1).toString(16),
    "0x" + BigInt(proofJson.eval_s2).toString(16),
    "0x" + BigInt(proofJson.eval_zw).toString(16),
  ];

  return proof;
}

function p256(n) {
  let nstr = n.toString(16);
  while (nstr.length < 64) nstr = "0" + nstr;
  nstr = `0x${nstr}`;
  return nstr;
}

async function groth16ExportSolidityCallData(_proof, _pub) {
  // const proof = unstringifyBigInts(_proof);
  const proof = ffjavascript.utils.unstringifyBigInts(_proof);
  const pub = ffjavascript.utils.unstringifyBigInts(_pub);

  const pA = [p256(proof.pi_a[0]), p256(proof.pi_a[1])];
  const pB = [
    [p256(proof.pi_b[0][1]), p256(proof.pi_b[0][0])],
    [p256(proof.pi_b[1][1]), p256(proof.pi_b[1][0])]
  ];
  const pC = [p256(proof.pi_c[0]), p256(proof.pi_c[1])];
  const pubSignals = pub.map(p256);

  return { pA, pB, pC, pubSignals };
}

/**
 * Fills missing fields in a UserOperation object with default values.
 * @param {Object} op - A partial UserOperation object.
 * @param {Object} defaults - Default values for the UserOperation.
 * @returns {Object} - A complete UserOperation object with defaults applied.
 */
function fillUserOpDefaults(op, defaults) {
  const partial = { ...op };
  // Remove keys with null or undefined values
  for (const key in partial) {
    if (partial[key] == null) {
      delete partial[key];
    }
  }
  // Merge defaults with provided partial UserOperation
  const filled = { ...defaults, ...partial };
  return filled;
}

// Export the function for use in other modules
module.exports = {
  parseProof,
  fillUserOpDefaults,
  computePedersenHash,
  address2Uint8Array32,
  numToBits,
  bitsToNum,
  pedersenHashMultipleInputs,
  groth16ExportSolidityCallData
};