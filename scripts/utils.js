// utils.js
const { ethers } = require("hardhat");
const circomlibjs = require("circomlibjs");
const ffjavascript = require("ffjavascript");
// const AddressZero = ethers.constants.AddressZero;

/**
 * Default values for a UserOperation object.
 */
// const DefaultsForUserOp = {
//   sender: AddressZero,
//   nonce: 0,
//   initCode: '0x',
//   callData: '0x',
//   callGasLimit: 0,
//   verificationGasLimit: 150000, // Default verification gas
//   preVerificationGas: 21000,   // Covers calldata cost
//   maxFeePerGas: 0,
//   maxPriorityFeePerGas: 1e9,
//   paymaster: AddressZero,
//   paymasterData: '0x',
//   paymasterVerificationGasLimit: 300000,
//   paymasterPostOpGasLimit: 0,
//   signature: '0x',
// };

// function buff2hex(buff) {
//   function i2hex(i) {
//     return ('0' + i.toString(16)).slice(-2);
//   }
//   return Array.from(buff).map(i2hex).join('');
// }

let pedersenInstance; 

function address2Uint8Array32(address) {
  addressBigInt = BigInt(address)
  addressBuff = ffjavascript.utils.leInt2Buff(addressBigInt)

  ret = new Uint8Array(32);
  for (let i = 0; i < addressBuff.length; i++) {
    ret[i+12] = addressBuff[i]
  }
  return ret;
}

async function computePedersenHash(message) {
  try {
    if (typeof message !== "string" || message.length === 0) {
      throw new Error("Message must be a non-empty string.");
    }

    // Initialize Pedersen hash
    if (!pedersenInstance) {
      pedersenInstance = await circomlibjs.buildPedersenHash();
    }

    // Convert message to Uint8Array
    const encodedMessage = new TextEncoder().encode(message);


    const encodedMessage32 = new Uint8Array(32);
    encodedMessage32.set(encodedMessage);

    // Compute Pedersen hash
    const hashBuffer = pedersenInstance.hash(encodedMessage32);

    let babyJub = await circomlibjs.buildBabyjub();
    let F = babyJub.F;
    const hP = babyJub.unpackPoint(hashBuffer);
    // console.log("hP[0]:", F.toObject(hP[0]));
    // console.log("hP[1]:", F.toObject(hP[1]));

    // Convert the resulting buffer to a BigInt
    const hashBigInt = ffjavascript.utils.leBuff2int(hashBuffer);
    // console.log("hashBigInt:", hashBigInt);

    return hashBigInt;
  } catch (error) {
    console.error("Error in computePedersenHash:", error.message);
    throw error;
  }
}

/**
 * Converts the proof JSON into an array of hexadecimal strings for Plonk verification.
 * @param {Object} proofJson - The proof object generated by snarkjs.plonk.fullProve.
 * @returns {Array} - An array of hexadecimal strings representing the proof.
 */
function parseProof(proofJson) {
  const proof = [
    "0x" + BigInt(proofJson.A[0]).toString(16),
    "0x" + BigInt(proofJson.A[1]).toString(16),
    "0x" + BigInt(proofJson.B[0]).toString(16),
    "0x" + BigInt(proofJson.B[1]).toString(16),
    "0x" + BigInt(proofJson.C[0]).toString(16),
    "0x" + BigInt(proofJson.C[1]).toString(16),
    "0x" + BigInt(proofJson.Z[0]).toString(16),
    "0x" + BigInt(proofJson.Z[1]).toString(16),
    "0x" + BigInt(proofJson.T1[0]).toString(16),
    "0x" + BigInt(proofJson.T1[1]).toString(16),
    "0x" + BigInt(proofJson.T2[0]).toString(16),
    "0x" + BigInt(proofJson.T2[1]).toString(16),
    "0x" + BigInt(proofJson.T3[0]).toString(16),
    "0x" + BigInt(proofJson.T3[1]).toString(16),
    "0x" + BigInt(proofJson.Wxi[0]).toString(16),
    "0x" + BigInt(proofJson.Wxi[1]).toString(16),
    "0x" + BigInt(proofJson.Wxiw[0]).toString(16),
    "0x" + BigInt(proofJson.Wxiw[1]).toString(16),
    "0x" + BigInt(proofJson.eval_a).toString(16),
    "0x" + BigInt(proofJson.eval_b).toString(16),
    "0x" + BigInt(proofJson.eval_c).toString(16),
    "0x" + BigInt(proofJson.eval_s1).toString(16),
    "0x" + BigInt(proofJson.eval_s2).toString(16),
    "0x" + BigInt(proofJson.eval_zw).toString(16),
  ];

  return proof;
}

/**
 * Fills missing fields in a UserOperation object with default values.
 * @param {Object} op - A partial UserOperation object.
 * @param {Object} defaults - Default values for the UserOperation.
 * @returns {Object} - A complete UserOperation object with defaults applied.
 */
function fillUserOpDefaults(op, defaults) {
  const partial = { ...op };
  // Remove keys with null or undefined values
  for (const key in partial) {
    if (partial[key] == null) {
      delete partial[key];
    }
  }
  // Merge defaults with provided partial UserOperation
  const filled = { ...defaults, ...partial };
  return filled;
}

// Export the function for use in other modules
module.exports = {
  parseProof,
  fillUserOpDefaults,
  computePedersenHash,
  address2Uint8Array32
};